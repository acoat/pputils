#
#+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!
#                                                                       #
#                                 SWANmat.py                            # 
#                                                                       #
#+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!
#
# Author: Pat Prodanovic, Ph.D., P.Eng.
# 
# Date: December 2, 2015
#
# Purpose: Script takes in a binary Matlab output file generated by a 
# run from an unstructured SWAN calculation, and outputs the data to a
# text file. Assume the SWAN output has ouput vars XP YP DEP HS DIR RTP
# which is achieved by having the following line in the *.swn file:
#
# BLOCK 'COMPGRID' NOHEAD 'out.mat' LAY 3 XP YP DEP HS DIR RTP 
#
# It assumes that the *.swn steering file is generated using the nautical
# direction convention (where the wind is coming from).
#
# For now, it only works for stationary SWAN simulations.
# TODO: update for non-stationary output as well
#
# Uses: Python2.7.9, Matplotlib v1.4.2, Numpy v1.8.2, Scipy 0.14.0
#
# Example:
#
# python SWANmat.py -m out.grd -i out.mat -o out.csv
# where:
# -m mesh which was used by unstructured swan
# -i output *.mat file generated by unstructured swan
# -o output *.csv file 
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Global Imports
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import os,sys                              # system parameters
import matplotlib.tri    as mtri           # matplotlib triangulations
import numpy             as np             # numpy
import scipy.io          as io             # scipy's io functions for loadmat()
from ppmodules.readMesh import *           # to get all readMesh functions
from ppmodules.writeMesh import *          # to get all writeMesh functions
# 
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# MAIN
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#
if len(sys.argv) != 7:
	print 'Wrong number of Arguments, stopping now...'
	print 'Usage:'
	print 'python SWANmat.py -m out.grd -i out.mat -o out.txt'
	sys.exit()

# I/O
adcirc_file = sys.argv[2]
input_file = sys.argv[4]         # input *.mat file
output_file = sys.argv[6]        # output *.csv file

# output *.csv file
fout = open(output_file, "w")

# uses scipy's loadmat function, and produces one master dictionary
mat = io.loadmat(input_file)

# load variable names from the *.mat file
v = mat.keys()

# v names are these strings
#['Hsig', 'RTpeak', 'Depth', 'Yp', 'Xp', 'Dir']

for i in range (len(v)):
	# find the variables in the mat dictionary
	if (v[i].find('Hsig') > -1):
		Hsig = mat['Hsig']
	elif(v[i].find('RTpeak') > -1):
		RTpeak = mat['RTpeak']
	elif(v[i].find('Dir') > -1):
		Dir = mat['Dir']
	elif(v[i].find('Xp') > -1):
		Xp = mat['Xp']
	elif(v[i].find('Yp') > -1):
		Yp = mat['Yp']
	elif(v[i].find('Depth') > -1):
		Depth = mat['Depth']
		
# the number of nodes in the file
num_pts = Hsig.shape[1]

# if the Depth in unstructured SWAN is negative, all output variables
# are reported as nan
index = list()
for i in range(num_pts):
	if (Depth[0,i] < 0.0):
		Hsig[0,i] = 0.0
		RTpeak[0,i] = 0.0
		Dir[0,i] = 0.0

# writes the SWAN output as a *.csv file

# write the header (var names in first line, units in second)
fout.write('Xp,Yp,Hsig,RTpeak,Dir,Depth' + '\n')
# fout.write('m,m,m,sec,deg,m' + '\n')

for i in range(num_pts):
	fout.write(str(Xp[0,i]) + ',' + str(Yp[0,i]) + ','+ str(Hsig[0,i]) + ',' +
		str(RTpeak[0,i]) + ','+ str(Dir[0,i]) + ','+ str(Depth[0,i]) + '\n')
			
# select output variables are written as an adcirc mesh file
# which works well for processing with pputils

# read the adcirc mesh file
n,e,x,y,z,ikle = readAdcirc(adcirc_file)

# name for the adcirc file before the extension
base_name = adcirc_file.split('.',1)[0]

# write the adcirc files (multiply by -1 for BK viewing ...)
writeAdcirc(n,e,x,y,-1*Hsig[0,:],ikle,base_name + '_Hsig.grd')
writeAdcirc(n,e,x,y,-1*RTpeak[0,:],ikle,base_name + '_RTpeak.grd')
writeAdcirc(n,e,x,y,-1*Depth[0,:],ikle,base_name + '_Depth.grd')
writeAdcirc(n,e,x,y,-1*Dir[0,:],ikle,base_name + '_Dir.grd')

'''
# write the individual vtk files too
# these are the field variables from SWAN
writeVTKscalar(n,e,x,y,Hsig[0,:],ikle,base_name + '_Hsig.vtk', 'Hsig')
writeVTKscalar(n,e,x,y,RTpeak[0,:],ikle,base_name + '_RTpeak.vtk', 'RTpeak')
writeVTKscalar(n,e,x,y,Depth[0,:],ikle,base_name + '_Depth.vtk', 'Depth')
'''
# these are the vector variables from SWAN
